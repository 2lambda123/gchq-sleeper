package sleeper.trino;

import io.trino.spi.connector.*;
import sleeper.trino.handle.SleeperSplit;
import sleeper.trino.handle.SleeperTableHandle;
import sleeper.trino.handle.SleeperTransactionHandle;
import sleeper.trino.remotesleeperconnection.SleeperConnectionAsTrino;

import javax.inject.Inject;

import static java.util.Objects.requireNonNull;

/**
 * Creates the splits which are used by the Trino framework to share the work across multiple workers.
 * <p>
 * In this implementation, each split reads data from a single Sleeper partition. The split holds the details of the
 * partition and also the details of all of the rowkey ranges which need to be returned from within that partition.
 * <p>
 * The splits are generated by combining the rowkey domains from both the static filter (supplied by {@link
 * SleeperTableHandle#getTupleDomain()}) and the dynamic filter (supplied by {@link
 * DynamicFilter#getCurrentPredicate()}). Splits will not be generated until the dynamic filter has narrowed
 * completely.
 */
public class SleeperSplitManager implements ConnectorSplitManager {
    private final SleeperConnectionAsTrino sleeperConnectionAsTrino;
    private final int maxSplitBatchSize;

    @Inject
    public SleeperSplitManager(SleeperConfig sleeperConfig,
                               SleeperConnectionAsTrino sleeperConnectionAsTrino) {
        requireNonNull(sleeperConfig);
        this.sleeperConnectionAsTrino = requireNonNull(sleeperConnectionAsTrino);
        this.maxSplitBatchSize = sleeperConfig.getMaxSplitBatchSize();
    }

    /**
     * Retrieve a {@link ConnectorSplitSource} to provide access to all of the {@link SleeperSplit} objects.
     *
     * @param transactionHandle       The transaction that these splits are to work under.
     * @param session                 The session that these splits are to work under.
     * @param tableHandle             The table that these splits are to be generated for, which includes a static
     *                                filter.
     * @param splitSchedulingStrategy The split scheduling strategy. This is ignored.
     * @param dynamicFilter           The dynamic filter waits until it is fully-narrowed and then combined with the
     *                                static filter.
     * @return The {@link ConnectorSplitSource}.
     */
    @Override
    public ConnectorSplitSource getSplits(ConnectorTransactionHandle transactionHandle,
                                          ConnectorSession session,
                                          ConnectorTableHandle tableHandle,
                                          SplitSchedulingStrategy splitSchedulingStrategy,
                                          DynamicFilter dynamicFilter) {
        return new SleeperSplitSource(
                sleeperConnectionAsTrino,
                (SleeperTransactionHandle) transactionHandle,
                (SleeperTableHandle) tableHandle,
                dynamicFilter,
                maxSplitBatchSize);
    }
}
